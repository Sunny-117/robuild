import { describe, expect, it } from 'vitest'
import { testBuild } from './helpers'

describe('plugin examples from docs', () => {
  describe('version inject plugin', () => {
    it('should inject version from package.json', async (context) => {
      const versionInjectPlugin = (options: { packagePath?: string; placeholder?: string } = {}) => {
        const { packagePath = './package.json', placeholder = '__VERSION__' } = options

        return {
          name: 'version-inject',
          transform: {
            filter: /\.(js|ts|mjs)$/,
            handler(code: string, id: string) {
              if (code.includes(placeholder)) {
                try {
                  const pkg = { version: '1.2.3' } // Mock package.json
                  return {
                    code: code.replace(
                      new RegExp(placeholder, 'g'),
                      JSON.stringify(pkg.version)
                    )
                  }
                } catch (error) {
                  console.warn('Failed to read package.json:', error)
                }
              }
              return null
            }
          }
        }
      }

      await testBuild({
        context,
        files: {
          'index.ts': `
            export const version = __VERSION__
            export const message = "Version: " + __VERSION__
          `,
          'package.json': JSON.stringify({ name: 'test', version: '1.0.0' })
        },
        config: {
          entries: [
            {
              type: 'bundle',
              input: 'index.ts',
              rolldown: {
                plugins: [versionInjectPlugin()]
              }
            }
          ]
        },
        afterBuild: async (outputDir) => {
          const { readFile } = await import('fs/promises')
          const { join } = await import('path')

          const output = await readFile(join(outputDir, 'index.mjs'), 'utf-8')
          expect(output).toContain('"1.2.3"')
          expect(output).toContain('Version: 1.2.3') // rolldown optimizes string concatenation
        }
      })
    })
  })

  describe('banner plugin', () => {
    it('should add banner to generated files', async (context) => {
      const bannerPlugin = (options: { banner?: string } = {}) => {
        const { banner = '/* Generated by robuild */' } = options

        return {
          name: 'banner',
          generateBundle(_options: any, bundle: any) {
            Object.keys(bundle).forEach(fileName => {
              const chunk = bundle[fileName]

              if (chunk.type === 'chunk') {
                chunk.code = `${banner}\n${chunk.code}`
              }
            })
          }
        }
      }

      await testBuild({
        context,
        files: {
          'index.ts': 'export const hello = "world"',
          'package.json': JSON.stringify({ name: 'test', version: '1.0.0' })
        },
        config: {
          entries: [
            {
              type: 'bundle',
              input: 'index.ts',
              rolldown: {
                plugins: [bannerPlugin({ banner: '/* Custom Banner */' })]
              }
            }
          ]
        },
        afterBuild: async (outputDir) => {
          const { readFile } = await import('fs/promises')
          const { join } = await import('path')

          const output = await readFile(join(outputDir, 'index.mjs'), 'utf-8')
          expect(output).toMatch(/^\/\* Custom Banner \*\/\n/)
        }
      })
    })
  })

  describe('conditional compile plugin', () => {
    it('should handle conditional compilation', async (context) => {
      const conditionalCompilePlugin = (options: { conditions: Record<string, boolean> }) => {
        const { conditions } = options

        return {
          name: 'conditional-compile',
          transform: {
            filter: /\.(js|ts|mjs)$/,
            handler(code: string, _id: string) {
              let result = code

              Object.entries(conditions).forEach(([condition, enabled]) => {
                const ifdefRegex = new RegExp(
                  `\\/\\*\\s*#ifdef\\s+${condition}\\s*\\*\\/([\\s\\S]*?)\\/\\*\\s*#endif\\s*\\*\\/`,
                  'g'
                )

                result = result.replace(ifdefRegex, (_match, content) => {
                  return enabled ? content.trim() : ''
                })
              })

              return { code: result }
            }
          }
        }
      }

      await testBuild({
        context,
        files: {
          'index.ts': `
            export const features = {
              /* #ifdef DEBUG */
              debug: true,
              /* #endif */
              /* #ifdef PRODUCTION */
              production: true,
              /* #endif */
              base: true
            }
          `,
          'package.json': JSON.stringify({ name: 'test', version: '1.0.0' })
        },
        config: {
          entries: [
            {
              type: 'bundle',
              input: 'index.ts',
              rolldown: {
                plugins: [conditionalCompilePlugin({
                  conditions: { DEBUG: true, PRODUCTION: false }
                })]
              }
            }
          ]
        },
        afterBuild: async (outputDir) => {
          const { readFile } = await import('fs/promises')
          const { join } = await import('path')

          const output = await readFile(join(outputDir, 'index.mjs'), 'utf-8')
          expect(output).toContain('debug: true')
          expect(output).not.toContain('production: true')
          expect(output).toContain('base: true')
        }
      })
    })
  })
})
