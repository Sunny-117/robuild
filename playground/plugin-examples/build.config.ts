import { defineConfig } from '../../src'
import { readFileSync } from 'fs'

// Version inject plugin
function versionInjectPlugin(options: { packagePath?: string; placeholder?: string } = {}) {
  const { packagePath = './package.json', placeholder = '__VERSION__' } = options

  return {
    name: 'version-inject',
    transform(code: string, _id: string) {
      if (code.includes(placeholder)) {
        try {
          const pkg = JSON.parse(readFileSync(packagePath, 'utf-8'))
          return {
            code: code.replace(
              new RegExp(placeholder, 'g'),
              JSON.stringify(pkg.version)
            )
          }
        } catch (error) {
          console.warn('Failed to read package.json:', error)
        }
      }
      return null
    }
  }
}

// Banner plugin
function bannerPlugin(options: { banner?: string; include?: RegExp; exclude?: RegExp } = {}) {
  const {
    banner = '/* Generated by robuild */',
    include = /\.(js|mjs|ts)$/,
    exclude
  } = options

  return {
    name: 'banner',
    generateBundle(_options: any, bundle: any) {
      Object.keys(bundle).forEach(fileName => {
        const chunk = bundle[fileName]

        if (chunk.type === 'chunk') {
          const shouldInclude = include.test(fileName)
          const shouldExclude = exclude && exclude.test(fileName)

          if (shouldInclude && !shouldExclude) {
            chunk.code = `${banner}\n${chunk.code}`
          }
        }
      })
    }
  }
}

// Conditional compile plugin
function conditionalCompilePlugin(options: { conditions: Record<string, boolean> }) {
  const { conditions } = options

  return {
    name: 'conditional-compile',
    transform(code: string, _id: string) {
      let result = code

      Object.entries(conditions).forEach(([condition, enabled]) => {
        const ifdefRegex = new RegExp(
          `\\/\\*\\s*#ifdef\\s+${condition}\\s*\\*\\/([\\s\\S]*?)\\/\\*\\s*#endif\\s*\\*\\/`,
          'g'
        )

        result = result.replace(ifdefRegex, (_match, content) => {
          return enabled ? content.trim() : ''
        })
      })

      return result !== code ? { code: result } : null
    }
  }
}

export default defineConfig({
  entries: [
    {
      type: 'bundle',
      input: './src/index.ts',
      rolldown: {
        plugins: [
          versionInjectPlugin(),
          bannerPlugin({
            banner: `/*!
 * Plugin Examples Demo
 * Built with robuild
 * Date: ${new Date().toISOString()}
 */`
          }),
          conditionalCompilePlugin({
            conditions: {
              DEBUG: process.env.NODE_ENV !== 'production',
              PRODUCTION: process.env.NODE_ENV === 'production',
              FEATURE_A: true,
              FEATURE_B: false
            }
          })
        ]
      }
    }
  ]
})
